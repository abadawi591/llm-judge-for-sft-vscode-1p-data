// =============================================================================
// SFT STRATIFIED SAMPLING BY TURN COUNT BUCKETS
// =============================================================================
// PURPOSE: Extract balanced conversations across turn count buckets
// 
// USE CASE: Conversation-aware router training where every turn is a sample
// 
// STRATIFICATION BUCKETS:
//   Bucket A: 3-5 turns   (typical short tasks)
//   Bucket B: 6-10 turns  (medium complexity)
//   Bucket C: 11-20 turns (complex multi-step)
//
// WHY STRATIFY?
// - Natural distribution is heavily skewed (60%+ have 1-3 turns)
// - Longer conversations are underrepresented but valuable
// - Each bucket contributes different turn positions for training
//
// SAMPLE SIZE STRATEGY:
// - Equal conversations per bucket (or weighted by inverse frequency)
// - Longer buckets contribute more turns per conversation
//
// DOCUMENTATION: See ../AGENT_SFT_DATA_GUIDE.md
// =============================================================================

let timeStart = ago(7d);
let timeEnd = now();

// Bucket configuration
let bucketA_min = 3;  let bucketA_max = 5;   let bucketA_sample = 5000;
let bucketB_min = 6;  let bucketB_max = 10;  let bucketB_sample = 5000;
let bucketC_min = 11; let bucketC_max = 20;  let bucketC_sample = 3000;

// Step 1: Get deduplicated messages
let rawMessages = 
    AppEvents
    | where TimeGenerated > timeStart and TimeGenerated <= timeEnd
    | where Name == "GitHub.copilot-chat/conversation.messageText"
    | extend mode = tostring(Properties["mode"])
    | where mode == "agent"
    | extend conversationId = tostring(Properties["conversationId"])
    | extend messageId = tostring(Properties["messageId"])
    | extend source = tostring(Properties["source"])
    | extend messageText = tostring(Properties["messageText"])
    | extend userName = tostring(Properties["common.userName"])
    | project TimeGenerated, conversationId, messageId, source, messageText, userName;

let dedupedByMessageId = 
    rawMessages
    | summarize arg_max(strlen(messageText), TimeGenerated, messageText, userName)
        by conversationId, messageId, source
    | where isnotempty(messageText);

let userMsgs = dedupedByMessageId 
    | where source == "user" 
    | project conversationId, messageId, userMessage = messageText, userName, userTime = TimeGenerated;

let modelMsgs = dedupedByMessageId 
    | where source == "model"
    | summarize arg_min(TimeGenerated, messageText) by conversationId, messageId
    | project conversationId, messageId, modelMessage = messageText;

// Step 2: Get token data with delta calculation
let tokenEvents = 
    AppEvents
    | where TimeGenerated > timeStart and TimeGenerated <= timeEnd
    | where Name == "GitHub.copilot-chat/engine.messages.length"
    | extend message_direction = tostring(Properties["message_direction"])
    | where message_direction == "output"
    | extend messageId = tostring(Properties["headerRequestId"])
    | extend model = tostring(Properties["baseModel"])
    | extend promptTokens = toint(Measurements["promptTokens"])
    | extend completionTokens = toint(Measurements["completionTokens"])
    | project TimeGenerated, messageId, model, promptTokens, completionTokens
    | order by messageId, TimeGenerated asc;

let tokenEventsWithDelta = 
    tokenEvents
    | extend prevMessageId = prev(messageId)
    | extend prevPromptTokens = prev(promptTokens)
    | extend promptTokenDelta = iif(messageId == prevMessageId, promptTokens - prevPromptTokens, promptTokens)
    | project messageId, model, promptTokens, promptTokenDelta, completionTokens;

let tokenData = 
    tokenEventsWithDelta
    | summarize 
        llmCalls = make_list(pack(
            "promptTokens", promptTokens,
            "promptTokenDelta", promptTokenDelta,
            "completionTokens", completionTokens,
            "model", model
        ))
        by messageId;

// Step 3: Get tool data
let toolData = 
    AppEvents
    | where TimeGenerated > timeStart and TimeGenerated <= timeEnd
    | where Name == "GitHub.copilot-chat/toolCallDetailsInternal"
    | extend messageId = tostring(Properties["messageId"])
    | extend toolCounts = tostring(Properties["toolCounts"])
    | extend responseType = tostring(Properties["responseType"])
    | extend turnIndex = toint(Measurements["turnIndex"])
    | extend numRequests = toint(Measurements["numRequests"])
    | extend turnDuration = toint(Measurements["turnDuration"])
    | where responseType == "success"
    | project messageId, toolCounts, turnIndex, numRequests, turnDuration;

// Step 4: Build turns
let turns = 
    userMsgs
    | join kind=inner modelMsgs on conversationId, messageId
    | join kind=inner tokenData on messageId
    | join kind=inner toolData on messageId
    | project-away conversationId1, messageId1, messageId2, messageId3
    | project 
        conversationId,
        userName,
        turnIndex,
        messageId,
        userMessage,
        modelMessage,
        llmCalls,
        toolCounts,
        numRequests,
        turnDuration;

// Step 5: Aggregate to conversations with completeness check
let conversations = 
    turns
    | order by conversationId asc, turnIndex asc
    | summarize 
        userName = take_any(userName),
        capturedTurnCount = count(),
        minTurnIndex = min(turnIndex),
        maxTurnIndex = max(turnIndex),
        turnsArray = make_list(pack(
            "turnIndex", turnIndex,
            "messageId", messageId,
            "userMessage", userMessage,
            "modelMessage", modelMessage,
            "llmCalls", llmCalls,
            "toolCounts", toolCounts,
            "numRequests", numRequests,
            "turnDurationMs", turnDuration
        ))
        by conversationId
    | mv-apply turnsArray on (
        order by toint(turnsArray.turnIndex) asc
        | summarize turnsArray = make_list(turnsArray)
    )
    // COMPLETENESS CHECK
    | where minTurnIndex == 1
    | where capturedTurnCount == maxTurnIndex
    // Assign bucket
    | extend bucket = case(
        capturedTurnCount >= bucketA_min and capturedTurnCount <= bucketA_max, "A_short",
        capturedTurnCount >= bucketB_min and capturedTurnCount <= bucketB_max, "B_medium",
        capturedTurnCount >= bucketC_min and capturedTurnCount <= bucketC_max, "C_long",
        "excluded"
    )
    | where bucket != "excluded";

// Step 6: Sample from each bucket
let bucketA = conversations | where bucket == "A_short" | sample bucketA_sample;
let bucketB = conversations | where bucket == "B_medium" | sample bucketB_sample;
let bucketC = conversations | where bucket == "C_long" | sample bucketC_sample;

// Step 7: Union all buckets
union bucketA, bucketB, bucketC
| project 
    conversationId, 
    userName, 
    bucket,
    capturedTurnCount,
    minTurnIndex,
    maxTurnIndex,
    isComplete = true,
    turns = turnsArray
| order by bucket asc, capturedTurnCount desc

